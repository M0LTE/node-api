<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Map - Node API</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            overflow: hidden;
        }
        .header {
            background-color: white;
            padding: 15px 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1000;
            position: relative;
        }
        h1 {
            color: #333;
            margin: 0;
            font-size: 24px;
        }
        .mqtt-status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 13px;
            margin-left: 10px;
        }
        .mqtt-status.connected {
            background-color: #4caf50;
            color: white;
        }
        .mqtt-status.disconnected {
            background-color: #f44336;
            color: white;
        }
        .mqtt-status.connecting {
            background-color: #ff9800;
            color: white;
        }
        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .links a {
            padding: 8px 16px;
            background-color: #0066cc;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        .links a:hover {
            background-color: #0052a3;
        }
        .filter-button {
            padding: 8px 16px;
            border: 2px solid #0066cc;
            background-color: white;
            color: #0066cc;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s;
        }
        .filter-button:hover {
            background-color: #f0f4ff;
        }
        .filter-button.active {
            background-color: #0066cc;
            color: white;
        }
        #network {
            width: 100%;
            height: calc(100vh - 180px);
            border: 1px solid #ddd;
            background-color: #fafafa;
        }
        .stats-panel {
            background-color: white;
            padding: 10px 20px;
            display: flex;
            justify-content: space-around;
            box-shadow: 0 -2px 4px rgba(0,0,0,0.1);
        }
        .stat-item {
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #0066cc;
        }
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
        }
        .legend {
            position: absolute;
            top: 80px;
            right: 20px;
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 500;
            font-size: 13px;
        }
        .legend-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }
        .legend-line {
            width: 40px;
            height: 3px;
            margin-right: 10px;
        }
        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
        }
        .rf-link {
            background-color: #4caf50;
        }
        .internet-link {
            background-color: #2196f3;
            opacity: 0.3;
        }
        .active-node {
            background-color: #0066cc;
        }
        .flashing-link {
            background: linear-gradient(90deg, #ffeb3b 0%, #ff9800 100%);
        }
        .zoom-controls {
            position: absolute;
            top: 80px;
            left: 20px;
            background-color: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 500;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .zoom-button {
            width: 40px;
            height: 40px;
            border: 2px solid #0066cc;
            background-color: white;
            color: #0066cc;
            border-radius: 4px;
            cursor: pointer;
            font-size: 20px;
            font-weight: bold;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .zoom-button:hover {
            background-color: #f0f4ff;
        }
        .zoom-button:active {
            background-color: #0066cc;
            color: white;
        }
    </style>
    <script type="text/javascript" src="https://unpkg.com/vis-network@9.1.9/dist/vis-network.min.js"></script>
    <script src="https://unpkg.com/mqtt@5.3.4/dist/mqtt.min.js"></script>
</head>
<body>
    <div class="header">
        <div>
            <h1>
                Network Map
                <span id="mqttStatus" class="mqtt-status connecting">Connecting...</span>
            </h1>
        </div>
        <div class="controls">
            <button class="filter-button" id="showRfOnlyBtn" onclick="toggleRfOnly()">
                üì° RF Links Only
            </button>
            <div class="links">
                <a href="/">Home</a>
                <a href="/links.html">Link Monitor</a>
                <a href="/circuits.html">Circuit Monitor</a>
            </div>
        </div>
    </div>

    <div id="network"></div>

    <div class="stats-panel">
        <div class="stat-item">
            <div class="stat-value" id="nodeCount">0</div>
            <div class="stat-label">Nodes</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="linkCount">0</div>
            <div class="stat-label">Active Links</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="rfLinkCount">0</div>
            <div class="stat-label">üì° RF Links</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="internetLinkCount">0</div>
            <div class="stat-label">üåê Internet Links</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="traceCount">0</div>
            <div class="stat-label">Traces (10s)</div>
        </div>
    </div>

    <div class="legend">
        <div class="legend-title">Legend</div>
        <div class="legend-item">
            <div class="legend-line rf-link"></div>
            <span>RF Link</span>
        </div>
        <div class="legend-item">
            <div class="legend-line internet-link"></div>
            <span>Internet / Unknown Link</span>
        </div>
        <div class="legend-item">
            <div class="legend-line" style="background: #ff6b00;"></div>
            <span>Traffic Active</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot active-node"></div>
            <span>Network Node</span>
        </div>
    </div>

    <div class="zoom-controls">
        <button class="zoom-button" onclick="zoomIn()" title="Zoom In">+</button>
        <button class="zoom-button" onclick="zoomOut()" title="Zoom Out">‚àí</button>
        <button class="zoom-button" onclick="resetZoom()" title="Fit to Screen">‚äô</button>
    </div>

    <script>
        // Network graph state
        let nodes = new vis.DataSet();
        let edges = new vis.DataSet();
        let network = null;
        let showRfOnly = false;
        let linkActivityMap = new Map(); // Track L2Trace activity per link
        let traceCounter = 0;
        let traceTimestamps = [];

        // Link tracker
        class LinkTracker {
            constructor() {
                this.links = new Map();
            }

            getCanonicalLinkKey(local, remote) {
                const [endpoint1, endpoint2] = [local, remote].sort();
                return `${endpoint1}<->${endpoint2}`;
            }

            handleLinkUp(data) {
                const canonicalKey = this.getCanonicalLinkKey(data.local, data.remote);
                
                let link = this.links.get(canonicalKey);
                
                if (!link) {
                    link = {
                        canonicalKey: canonicalKey,
                        endpoint1: data.local < data.remote ? data.local : data.remote,
                        endpoint2: data.local < data.remote ? data.remote : data.local,
                        status: 'active',
                        isRF: null
                    };
                    this.links.set(canonicalKey, link);
                    
                    // Ensure both endpoint nodes exist
                    if (!nodes.get(link.endpoint1)) {
                        nodes.add({ 
                            id: link.endpoint1, 
                            label: link.endpoint1, 
                            shape: 'dot', 
                            size: 15,
                            title: link.endpoint1 
                        });
                    }
                    if (!nodes.get(link.endpoint2)) {
                        nodes.add({ 
                            id: link.endpoint2, 
                            label: link.endpoint2, 
                            shape: 'dot', 
                            size: 15,
                            title: link.endpoint2 
                        });
                    }
                }
                
                link.status = 'active';
                scheduleUpdate();
            }

            handleLinkStatus(data) {
                const canonicalKey = this.getCanonicalLinkKey(data.local, data.remote);
                
                let link = this.links.get(canonicalKey);
                
                if (!link) {
                    link = {
                        canonicalKey: canonicalKey,
                        endpoint1: data.local < data.remote ? data.local : data.remote,
                        endpoint2: data.local < data.remote ? data.remote : data.local,
                        status: 'active',
                        isRF: null
                    };
                    this.links.set(canonicalKey, link);
                    
                    // Ensure both endpoint nodes exist
                    if (!nodes.get(link.endpoint1)) {
                        nodes.add({ 
                            id: link.endpoint1, 
                            label: link.endpoint1, 
                            shape: 'dot', 
                            size: 15,
                            title: link.endpoint1 
                        });
                    }
                    if (!nodes.get(link.endpoint2)) {
                        nodes.add({ 
                            id: link.endpoint2, 
                            label: link.endpoint2, 
                            shape: 'dot', 
                            size: 15,
                            title: link.endpoint2 
                        });
                    }
                }
                
                link.status = 'active';
                scheduleUpdate();
            }

            handleLinkDown(data) {
                const canonicalKey = this.getCanonicalLinkKey(data.local, data.remote);
                const link = this.links.get(canonicalKey);
                
                if (link) {
                    link.status = 'disconnected';
                    scheduleUpdate();
                }
            }

            handleL2Trace(data) {
                // Track trace activity between source and destination
                if (data.srce && data.dest) {
                    const canonicalKey = this.getCanonicalLinkKey(data.srce, data.dest);
                    
                    // Update RF status if available
                    let link = this.links.get(canonicalKey);
                    if (link && data.isRF !== undefined && data.isRF !== null) {
                        link.isRF = data.isRF;
                    }
                    
                    // Track traffic activity and direction
                    linkActivityMap.set(canonicalKey, {
                        timestamp: Date.now(),
                        from: data.srce,
                        to: data.dest
                    });
                    
                    // Don't add nodes here - let the link endpoints create them
                    // This prevents flashing nodes in the center
                    
                    scheduleUpdate();
                }
            }

            getActiveLinks() {
                return Array.from(this.links.values())
                    .filter(link => link.status === 'active');
            }

            getAllLinks() {
                return Array.from(this.links.values());
            }
        }

        const linkTracker = new LinkTracker();
        const mqttUrl = 'wss://node-api.packet.oarc.uk:443/mqtt/';
        const statusElement = document.getElementById('mqttStatus');

        // Load initial state from API
        async function loadInitialState() {
            try {
                const response = await fetch('/api/links');
                if (response.ok) {
                    const links = await response.json();
                    console.log(`Loaded ${links.length} links from API`);
                    
                    links.forEach(link => {
                        linkTracker.links.set(link.canonicalKey, {
                            canonicalKey: link.canonicalKey,
                            endpoint1: link.endpoint1,
                            endpoint2: link.endpoint2,
                            status: link.status === 0 ? 'active' : 'disconnected',
                            isRF: link.isRF
                        });
                    });
                    
                    updateNetworkGraph();
                }
            } catch (err) {
                console.error('Error loading initial state:', err);
            }
        }

        // Initialize the network graph
        function initializeNetwork() {
            const container = document.getElementById('network');
            const data = { nodes: nodes, edges: edges };
            
            const options = {
                nodes: {
                    shape: 'dot',
                    size: 15,
                    font: {
                        size: 14,
                        color: '#333',
                        face: 'Courier New',
                        bold: {
                            color: '#000',
                            size: 16
                        }
                    },
                    borderWidth: 2,
                    borderWidthSelected: 4,
                    color: {
                        border: '#2B7CE9',
                        background: '#97C2FC',
                        highlight: {
                            border: '#2B7CE9',
                            background: '#D2E5FF'
                        },
                        hover: {
                            border: '#2B7CE9',
                            background: '#D2E5FF'
                        }
                    },
                    chosen: true
                },
                edges: {
                    width: 2,
                    smooth: {
                        type: 'dynamic',
                        roundness: 0.5
                    },
                    arrows: {
                        to: {
                            enabled: false,
                            scaleFactor: 0.5
                        }
                    },
                    font: {
                        size: 11,
                        align: 'middle'
                    }
                },
                physics: {
                    enabled: true,
                    barnesHut: {
                        gravitationalConstant: -8000,
                        centralGravity: 0.3,
                        springLength: 250,
                        springConstant: 0.04,
                        damping: 0.09,
                        avoidOverlap: 0.5
                    },
                    maxVelocity: 50,
                    solver: 'barnesHut',
                    stabilization: {
                        enabled: true,
                        iterations: 1000,
                        updateInterval: 25
                    },
                    adaptiveTimestep: true
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    hideEdgesOnDrag: false,
                    hideEdgesOnZoom: false,
                    zoomView: true,
                    dragView: true,
                    navigationButtons: false
                },
                // Enable tooltips explicitly
                tooltips: {
                    enabled: true,
                    delay: 100
                }
            };
            
            network = new vis.Network(container, data, options);
            
            // Custom tooltip handling as fallback
            network.on('hoverNode', function(params) {
                const nodeId = params.node;
                const node = nodes.get(nodeId);
                if (node && node.title) {
                    network.canvas.body.container.title = node.title;
                }
            });
            
            network.on('blurNode', function(params) {
                network.canvas.body.container.title = '';
            });
            
            // Handle node clicks - navigate to node detail page
            network.on('selectNode', function(params) {
                if (params.nodes.length > 0) {
                    const nodeId = params.nodes[0];
                    window.open(`/node.html?callsign=${nodeId}`, '_blank');
                }
            });
            
            // Handle edge clicks - show link info
            network.on('selectEdge', function(params) {
                if (params.edges.length > 0) {
                    const edgeId = params.edges[0];
                    const edge = edges.get(edgeId);
                    if (edge && edge.title) {
                        console.log(edge.title);
                    }
                }
            });
        }

        function updateNetworkGraph() {
            const activeLinks = linkTracker.getActiveLinks();
            const now = Date.now();
            const activityTimeout = 2000; // 2 seconds for fade out
            
            // Filter links based on RF filter
            let filteredLinks = activeLinks;
            if (showRfOnly) {
                filteredLinks = activeLinks.filter(link => link.isRF === true);
            }
            
            // Update stats
            const rfCount = activeLinks.filter(l => l.isRF === true).length;
            const internetCount = activeLinks.filter(l => l.isRF === false).length;
            
            document.getElementById('linkCount').textContent = filteredLinks.length;
            document.getElementById('rfLinkCount').textContent = rfCount;
            document.getElementById('internetLinkCount').textContent = internetCount;
            
            // Build set of all nodes from active links
            const activeNodes = new Set();
            filteredLinks.forEach(link => {
                activeNodes.add(link.endpoint1);
                activeNodes.add(link.endpoint2);
            });
            
            // Update nodes - batch operations
            const existingNodeIds = nodes.getIds();
            const newNodeIds = Array.from(activeNodes);
            
            // Collect nodes to add/remove
            const nodesToAdd = [];
            const nodesToRemove = [];
            const nodesToUpdate = [];
            
            // Add new nodes or update existing ones
            newNodeIds.forEach(nodeId => {
                if (!existingNodeIds.includes(nodeId)) {
                    nodesToAdd.push({
                        id: nodeId,
                        label: nodeId,
                        shape: 'dot',
                        size: 15,
                        title: nodeId // Tooltip shows callsign
                    });
                } else {
                    // Update existing node to ensure it has a title
                    nodesToUpdate.push({
                        id: nodeId,
                        title: nodeId
                    });
                }
            });
            
            // Remove nodes that are no longer active
            existingNodeIds.forEach(nodeId => {
                if (!newNodeIds.includes(nodeId)) {
                    nodesToRemove.push(nodeId);
                }
            });
            
            // Batch update nodes
            if (nodesToAdd.length > 0) {
                nodes.add(nodesToAdd);
            }
            if (nodesToUpdate.length > 0) {
                nodes.update(nodesToUpdate);
            }
            if (nodesToRemove.length > 0) {
                nodes.remove(nodesToRemove);
            }
            
            // Update edges - batch operations
            const existingEdgeIds = edges.getIds();
            const edgesToAdd = [];
            const edgesToUpdate = [];
            const edgesToRemove = [];
            const newEdgeIds = [];
            
            filteredLinks.forEach(link => {
                const edgeId = link.canonicalKey;
                const activityData = linkActivityMap.get(edgeId);
                const timeSinceActivity = activityData ? (now - activityData.timestamp) : Infinity;
                const isActive = activityData && timeSinceActivity < activityTimeout;
                
                let color, width, arrows;
                
                // Determine color and appearance based on activity and RF status
                if (isActive) {
                    // Calculate fade based on time since activity (0 = just happened, 1 = timeout reached)
                    const fadeProgress = Math.min(timeSinceActivity / activityTimeout, 1);
                    
                    // Start with high contrast red/orange, fade to base color
                    const baseColor = link.isRF === true ? '#4caf50' : 
                                     link.isRF === false ? '#2196f3' : '#ff9800';
                    
                    // Interpolate from bright orange (#ff6b00) to base color
                    const activeIntensity = 1 - fadeProgress;
                    const orangeRed = Math.round(255 * activeIntensity + parseInt(baseColor.substr(1,2), 16) * (1 - activeIntensity));
                    const orangeGreen = Math.round(107 * activeIntensity + parseInt(baseColor.substr(3,2), 16) * (1 - activeIntensity));
                    const orangeBlue = Math.round(0 * activeIntensity + parseInt(baseColor.substr(5,2), 16) * (1 - activeIntensity));
                    const currentColor = `rgb(${orangeRed}, ${orangeGreen}, ${orangeBlue})`;
                    
                    color = {
                        color: currentColor,
                        highlight: '#ff6b00',
                        hover: '#ff6b00'
                    };
                    
                    // Width fades from 5 to base width
                    const baseWidth = (link.isRF === false || link.isRF === null) ? 1 : 2;
                    width = 5 * (1 - fadeProgress * 0.6) + baseWidth * (fadeProgress * 0.6);
                    
                    // Arrows with dynamic size based on fade
                    const arrowsTo = activityData.to === link.endpoint2;
                    const arrowScale = 1.5 - (fadeProgress * 0.5); // Scale from 1.5 to 1.0
                    arrows = {
                        to: {
                            enabled: arrowsTo,
                            scaleFactor: arrowScale,
                            type: 'arrow'
                        },
                        from: {
                            enabled: !arrowsTo,
                            scaleFactor: arrowScale,
                            type: 'arrow'
                        }
                    };
                } else if (link.isRF === true) {
                    color = {
                        color: '#4caf50',
                        highlight: '#66bb6a',
                        hover: '#66bb6a'
                    };
                    width = 2;
                    arrows = { to: { enabled: false }, from: { enabled: false } };
                } else if (link.isRF === false) {
                    color = {
                        color: '#2196f3',
                        highlight: '#42a5f5',
                        hover: '#42a5f5',
                        opacity: 0.3
                    };
                    width = 1;
                    arrows = { to: { enabled: false }, from: { enabled: false } };
                } else {
                    // Unknown - treat exactly the same as internet links
                    color = {
                        color: '#2196f3',
                        highlight: '#42a5f5',
                        hover: '#42a5f5',
                        opacity: 0.3
                    };
                    width = 1;
                    arrows = { to: { enabled: false }, from: { enabled: false } };
                }
                
                // Build tooltip
                const rfStatus = link.isRF === true ? 'üì° RF' : 
                                link.isRF === false ? 'üåê Internet' : '‚ùì Unknown';
                let title = `${link.endpoint1} ‚Üî ${link.endpoint2}\n${rfStatus}`;
                
                // Add direction info if active
                if (isActive && activityData) {
                    title += `\n‚Üí Traffic: ${activityData.from} ‚Üí ${activityData.to}`;
                }
                
                const edge = {
                    id: edgeId,
                    from: link.endpoint1,
                    to: link.endpoint2,
                    color: color,
                    width: width,
                    arrows: arrows,
                    title: title
                };
                
                newEdgeIds.push(edgeId);
                
                // Update existing edge or add new one
                if (existingEdgeIds.includes(edgeId)) {
                    edgesToUpdate.push(edge);
                } else {
                    edgesToAdd.push(edge);
                }
            });
            
            // Remove edges that are no longer active
            existingEdgeIds.forEach(edgeId => {
                if (!newEdgeIds.includes(edgeId)) {
                    edgesToRemove.push(edgeId);
                }
            });
            
            // Batch update edges
            if (edgesToAdd.length > 0) {
                edges.add(edgesToAdd);
            }
            if (edgesToUpdate.length > 0) {
                edges.update(edgesToUpdate);
            }
            if (edgesToRemove.length > 0) {
                edges.remove(edgesToRemove);
            }
            
            document.getElementById('nodeCount').textContent = nodes.length;
            
            // Update trace count (rolling 10-second window)
            const cutoff = now - 10000;
            traceTimestamps = traceTimestamps.filter(t => t > cutoff);
            document.getElementById('traceCount').textContent = traceTimestamps.length;
        }

        function toggleRfOnly() {
            showRfOnly = !showRfOnly;
            const btn = document.getElementById('showRfOnlyBtn');
            
            if (showRfOnly) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
            
            updateNetworkGraph();
        }

        // Zoom control functions
        function zoomIn() {
            if (network) {
                const scale = network.getScale();
                network.moveTo({
                    scale: scale * 1.2,
                    animation: {
                        duration: 300,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            }
        }

        function zoomOut() {
            if (network) {
                const scale = network.getScale();
                network.moveTo({
                    scale: scale * 0.8,
                    animation: {
                        duration: 300,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            }
        }

        function resetZoom() {
            if (network) {
                network.fit({
                    animation: {
                        duration: 500,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            }
        }

        // MQTT connection
        loadInitialState();
        initializeNetwork();

        const client = mqtt.connect(mqttUrl);

        client.on('connect', () => {
            console.log('Connected to MQTT broker');
            statusElement.textContent = 'Connected';
            statusElement.className = 'mqtt-status connected';
            
            client.subscribe('out/LinkUpEvent', (err) => {
                if (err) console.error('Error subscribing to out/LinkUpEvent:', err);
            });
            client.subscribe('out/LinkStatus', (err) => {
                if (err) console.error('Error subscribing to out/LinkStatus:', err);
            });
            client.subscribe('out/LinkDownEvent', (err) => {
                if (err) console.error('Error subscribing to out/LinkDownEvent:', err);
            });
            client.subscribe('out/L2Trace', (err) => {
                if (err) console.error('Error subscribing to out/L2Trace:', err);
            });
        });

        client.on('message', (topic, message) => {
            try {
                const data = JSON.parse(message.toString());
                
                if (topic === 'out/LinkUpEvent') {
                    linkTracker.handleLinkUp(data);
                } else if (topic === 'out/LinkStatus') {
                    linkTracker.handleLinkStatus(data);
                } else if (topic === 'out/LinkDownEvent') {
                    linkTracker.handleLinkDown(data);
                } else if (topic === 'out/L2Trace') {
                    linkTracker.handleL2Trace(data);
                    traceCounter++;
                    traceTimestamps.push(Date.now());
                }
            } catch (err) {
                console.error('Error parsing message:', err);
            }
        });

        client.on('error', (err) => {
            console.error('MQTT connection error:', err);
            statusElement.textContent = 'Error';
            statusElement.className = 'mqtt-status disconnected';
        });

        client.on('offline', () => {
            statusElement.textContent = 'Disconnected';
            statusElement.className = 'mqtt-status disconnected';
        });

        client.on('reconnect', () => {
            statusElement.textContent = 'Reconnecting...';
            statusElement.className = 'mqtt-status connecting';
        });

        // Update display periodically to fade out activity indicators
        let updateScheduled = false;
        function scheduleUpdate() {
            if (!updateScheduled) {
                updateScheduled = true;
                requestAnimationFrame(() => {
                    updateNetworkGraph();
                    updateScheduled = false;
                });
            }
        }
        
        setInterval(scheduleUpdate, 500); // Update 2 times per second for smooth activity fadeout
    </script>
</body>
</html>
